---
title: 原生优雅的多线程机制
date: 2018-10-07 23:51:04
tags: Android多线程
---

# 原生优雅的多线程机制
> 上一篇系列大概讲解了掉帧的原因与16ms的由来。掉帧的原因取决于缓冲区是否在下一次VSYNC信号来临的时候准备好帧数据，其中这个数据来源包括CPU与GPU的处理。我们都明白要解决掉帧问题除了view过渡绘制、层级问题，还要尽量避免在UI线程（即主线程）做大量的耗时工作。即使Android使用三级缓存的形式处理掉帧的平滑过度，但是也无法减少我们日常开发的优化工作，所以多线程的优化更显示得更为重要。

## Android 自带的多线程机制

+ IntentService
适合由UI触发的后台Service任务，可以通过一定的机制反馈给UI
+ AsyncTask
提供主线程可以快速切换到异步线程的异步机制，适合短暂切换异步执行的场景
+ HandlerThread
提供了线程任务的调度机制（looper+handler），用于专属的线程执行某些特定的任务
+ ThreadPool
线程池，适合并发处理任务的机制

## 一个少而精的IntentService
IntentService 源码不到100行左右，但是却提供了一个解决了service问题的异步执行机制

![](https://lilei.work/img/160224_app_s5ep7/large_intent_work.png)
IntentService可以说是Service与HandlerThread的结合体。IntentService继承于Service，但是在onCreate的时候会创建HandlerThread。
``` java
 @Override
    public void onCreate() {
        // TODO: It would be nice to have an option to hold a partial wakelock
        // during processing, and to have a static startService(Context, Intent)
        // method that would launch the service & hand off a wakelock.

        super.onCreate();
        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");
        thread.start();

        mServiceLooper = thread.getLooper();
        mServiceHandler = new ServiceHandler(mServiceLooper);
    }
```
### Service的弊端是？
首先Service是默认运行在主线程的，如果要运行一定的后台程序，一般是会在Service中定义一个thread进行处理。所以Service会一定程度的影响主线程的绘制线程。

### IntentService是运行机制？
IntentService是Service与HandlerThread的结合体，在每次启动IntentService后，会主动调用到onStartCommand，此时会调用到onStart后，通过mServiceHandler代理发送一个含有我们启动参数intent的消息（这里的intent可以传递启动IntentService后执行的后台程序参数或配置）。最后通过handler的handleMessage中回调onHandleIntent抽象方法，过程如下：

``` java
context.startService -> onStartCommand -> onStart -> mServiceHandler (发送Message) -> handleMessage -> onHandleIntent(自定义处理)
```

最后当onHandleIntent处理完成的时候，IntentService会主动调用stopSelf停止IntentService。当然此时的IntentService并不会走向destory。由于顶层是基于HandlerThread进行消息管理，所以IntentService是支持多次start，则意味着让mServiceHandler发送多次消息，当然这些都是交给looper的消息队列进行管理的

### IntentService  优势与劣势
+ 优势：减少后台进程被杀死
了解了进程的优先级后会发现
1. 前台进程(Foreground process)
2. 可见进程(Visible process)
3. 服务进程(Service process)
4. 后台进程(Background process)
5. 空进程(Empty process)
IntentService会使你的app在被切换到后台时，不那么容易被杀死。（相比于那些在后台运行且没有Service的app而言）

![](https://lilei.work/img/160224_app_s5ep7/not_killed.png)
+ 劣势：
IntentService 用于是根据ServiceHandler来决定启动任务的，当然这些都是交给looper的消息队列进行管理的。所以这里意味着所有的任务也是线性按照队列执行的。加入在第一个队列中任务执行很长的实际，那么它后面的所有任务队列都会被一直的延时。

![](https://lilei.work/img/160224_app_s5ep7/one_work_queue.png)

## 一个优雅的HandlerThread


## 一个爱又恨的AsyncTask

## 一个大方的ThreadPool

# 参考文献
+ [Android Perfomance Patterns](https://lilei.work/2016/02/24/Android-Performance-Patterns-s5ep7-The-Zen-Of-IntentService/)
+ [Android IntentService完全解析 当Service遇到Handler](https://blog.csdn.net/lmj623565791/article/details/47143563)