<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="小知识 - 灵活对象的构建与销毁篇"><meta name="keywords" content="EffectJava"><meta name="author" content="siven.wu,undefined"><meta name="copyright" content="siven.wu"><title>小知识 - 灵活对象的构建与销毁篇 | 一IT届吸猫狂 · siven.wu</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#小知识-灵活对象的构建与销毁篇"><span class="toc-number">1.</span> <span class="toc-text"># 小知识 - 灵活对象的构建与销毁篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、静态方法替代构造方法"><span class="toc-number">1.1.</span> <span class="toc-text">一、静态方法替代构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-number">1.1.1.</span> <span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）表达更加清晰"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">（一）表达更加清晰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）灵活控制创建的对象-从实例化的角度"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">（二）灵活控制创建的对象(从实例化的角度)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）灵活控制返回对象-从继承的角度"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">（三）灵活控制返回对象(从继承的角度)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-number">1.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、及时销毁不引用的对象"><span class="toc-number">1.2.</span> <span class="toc-text">二、及时销毁不引用的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、适当维护程序的对象池"><span class="toc-number">1.3.</span> <span class="toc-text">三、适当维护程序的对象池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、finalize-终结方法"><span class="toc-number">1.4.</span> <span class="toc-text">四、finalize 终结方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要说什么的例子呢？"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">为什么要说什么的例子呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">finalize</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://pfpoo3r6f.bkt.clouddn.com/avater.jpg"></div><div class="author-info__name text-center">siven.wu</div><div class="author-info__description text-center">梦想，一直在路上</div><div class="follow-button"><a href="https://github.com/YuanClouds" target="_blank">关注我吧</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://pfpoo3r6f.bkt.clouddn.com/blog_top_bg_2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">一IT届吸猫狂 · siven.wu</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a></span></div><div id="post-info"><div id="post-title">小知识 - 灵活对象的构建与销毁篇</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="小知识-灵活对象的构建与销毁篇"><a href="#小知识-灵活对象的构建与销毁篇" class="headerlink" title="# 小知识 - 灵活对象的构建与销毁篇"></a># 小知识 - 灵活对象的构建与销毁篇</h1><h2 id="一、静态方法替代构造方法"><a href="#一、静态方法替代构造方法" class="headerlink" title="一、静态方法替代构造方法"></a>一、静态方法替代构造方法</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="（一）表达更加清晰"><a href="#（一）表达更加清晰" class="headerlink" title="（一）表达更加清晰"></a>（一）表达更加清晰</h4><p>总所周知，java中的构造方法是允许定义多个的。当一个对象具有不同特征属性的时候，需要构造不同的属性对象的方法有两种。</p>
<ul>
<li>提供多个不同对象属性的构造方法</li>
<li>提供set方法，开发者进行实例化时针对性进行需要的set<br>其中，提供不同的对象属性构造方法无疑会造成使用的开发者理解不清晰，举下下面的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** 假如一个猫cat类，有一是否有斑纹的属性（默认没有）**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasStripe;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name,<span class="keyword">boolean</span> hasStripe)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果有更多的特殊属性，那无疑就是会增加更多表达模糊的构造方法。如果借鉴工厂方法的思路，也许会不会更清晰点？例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;    </span><br><span class="line">    <span class="comment">//,,,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">getHasStripeCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 实例有虎纹的猫...</span></span><br><span class="line">     &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">getNormalCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//. 实例默认的猫..</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然有更加推荐的办法去解决这种多构造方法造成表达模糊的方法，即设计模式Builder模式。其中在android源码、其他依赖库原来越多利用这种构造模式，灵活又具有针对性</p>
<h4 id="（二）灵活控制创建的对象-从实例化的角度"><a href="#（二）灵活控制创建的对象-从实例化的角度" class="headerlink" title="（二）灵活控制创建的对象(从实例化的角度)"></a>（二）灵活控制创建的对象(从实例化的角度)</h4><p>先看下这句源码：Boolean.valueOf(***) ，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>valueOf是一个静态方法（替换构造方法提供实例化对象实例），TRUE与FALSE是Boolean类中的属性Boolean对象，因此利用静态方法替换构造方法一个优势就是可以动态得返回实例化的对象，例如Boolean的valueOf方法，这样即可以循环利用Boolean实例对象，又可以在大对象时new造成的内存的浪费</p>
<h4 id="（三）灵活控制返回对象-从继承的角度"><a href="#（三）灵活控制返回对象-从继承的角度" class="headerlink" title="（三）灵活控制返回对象(从继承的角度)"></a>（三）灵活控制返回对象(从继承的角度)</h4><p>面向对象开发的较大的优势-“继承”。父类可以代表其下所有的子类引用，基于这点静态方法有一个较大的优势，例如A为一个定义的基类，B是继承于A的子类，C也是继承于A的子类。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果类中实例化对象只有通过静态工厂方法而没有自身的构造方法，则这个类将会失去子类化。即静态工厂方法无法被子类进行继承</p>
<h2 id="二、及时销毁不引用的对象"><a href="#二、及时销毁不引用的对象" class="headerlink" title="二、及时销毁不引用的对象"></a>二、及时销毁不引用的对象</h2><p>回想起好几年前写c++，再遇到java的时候，jvn的垃圾回收器简直就是女神。虽然有了垃圾回收机制，大大的减少手动释放内存空间的工作量。但是并不是刻意”完全”不用管理内存，垃圾回收器也会遇到内存泄漏问题。<br>引用案例的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 某一堆栈管理类，Push表示入栈，pop表示出栈**/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类问题比较特殊，由于栈内部会维护对象的过期引用（过期引用：用于不会再解除引用）。在方法pop（）中只是返回了elements[i]的对象，但是实际elements依然是持有这个对象的引用的。因此这个对象将不能被正常的回收。优化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、适当维护程序的对象池"><a href="#三、适当维护程序的对象池" class="headerlink" title="三、适当维护程序的对象池"></a>三、适当维护程序的对象池</h2><p>new Object() 的时候会创建实例对象，如果在程序运行期间频繁地进行实例操作，也许会带来内存抖动。特别是重量级的对象，会引发一定的性能问题。<br>Boolean 内部就典型地维护了个对象轻量级的对象池，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">    * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment">    * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中在 valueOf 的时候会直接饮用这个对象池实例。valueOf 本身是作为转化对象而不是创建对象，因此通过对象池进行对象的转换。即减少了内存空间，又实现了目的。</p>
<h2 id="四、finalize-终结方法"><a href="#四、finalize-终结方法" class="headerlink" title="四、finalize 终结方法"></a>四、finalize 终结方法</h2><p>finalize 可以理解成C++的析构函数。在讲finalize的时候，先举例有内存泄漏隐患的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TranslateTool</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ITranslateTool mITranslateTool;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITranslateTool</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onResult</span><span class="params">(String result)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TranslateTool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(String text, ITranslateTool iTranslateTool)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mITranslateTool = iTranslateTool;</span><br><span class="line">        <span class="comment">//...异步操作 begin</span></span><br><span class="line">        iTranslateTool.onResult(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//...异步操作 end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mITranslateTool = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TranslateTool是一个翻译工具类，调用者通过调用doing进行异步翻译工作。首先mITranslateTool是外部持有的一个监听回调器，假如在TranslateTool翻译异步工作中（mITranslateTool由Activity实现持有），这时候在销毁Activity的时候如果忘记调用TranslateTool的 onDestory 方法。此时mITranslateTool的生命周期将会比Activity长，所以将会引起Activity不能被及时释放导致内存泄漏。</p>
<h4 id="为什么要说什么的例子呢？"><a href="#为什么要说什么的例子呢？" class="headerlink" title="为什么要说什么的例子呢？"></a><strong>为什么要说什么的例子呢？</strong></h4><p>很多时候代码自己写的，但是维护不一定是你自己。所以这里就很容易出现忘记调用onDestory解除Activity的引用。这里onDestory释放属于显示调用。那么有没有办法可以隐式调用释放解除Activity的引用呢？答案就是 终结方法 finalize。</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a><strong>finalize</strong></h4><p>finalize 有个好处，为了避免开发者忘记显示调用释放方法而提供一个”安全网”，但是并不能保证finalize是及时调用的。原因在于如果是一些需要及时关闭的场景，例如stream、cusor、file等，不能完全依赖finalize，而是需要尝试try…catch…finally..</p>
<p>如果类中实现了自己的finalize方法，通过继承该类中，如果忘记调用了父类的finalize，依然会出现上面的问题，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"siven"</span>,<span class="string">"父类终结..."</span>);</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Log.d(<span class="string">"siven"</span>,<span class="string">"子类终结"</span>);</span><br><span class="line">               <span class="comment">// super.finalize(); // 忘记调用父类了</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何解决？</strong><br>Parent可以定义一个对象属性，用于决定Parent的一些引用释放，从而解除了必须由子类要进行supper.finalize()的必要性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object finalizerGuardian = <span class="keyword">new</span> Object()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            onDestory();</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 移除</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finalizerGuardian属于私有对象属性，因此引用只有被该类的实例对象引用，生命周期与该类的实例对象一致。因此子类的finalize方法是否要调用super.finalize不是必要的问题了。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">siven.wu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yuanclouds.cn/2018/09/12/effect-java-1/">http://yuanclouds.cn/2018/09/12/effect-java-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/EffectJava/">EffectJava</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/09/12/effect-java-2/"><i class="fa fa-chevron-left">  </i><span>小知识 - 类与接口篇</span></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By siven.wu</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Halo, welcome to my <a href="https://yuanclouds.cn">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>